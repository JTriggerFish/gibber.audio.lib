{
  "!name": "gibber",
  "!define": {
    "presetName": {
      "name": "string"
    },
    "properties": {
      "name": "string"
    },
    "duration": {
      "seq": {
        "!type": "fn(values: ?, timings?: ?, seq_id?: number)",
        "!doc": "The seq method enables you to easily sequence any method or property. You can pass a single value or an array of values for both the 'values' and 'timings' arguments. The timings argument will determine when the sequencer fires and the values argument will determine output."
      },
      "sequencers": {
        "!type": "[]",
        "!doc": "Stores all scheduler instances created by calling .seq on this property/method."
      },
      "start": {
        "!type": "fn()",
        "!doc": "Starts all seq and tidal schedulers controlling this property/method."
      },
      "stop": {
        "!type": "fn(pattern: string)",
        "!doc": "Stops all seq and tidal schedulers controlling this property/method."
      },
      "tidal": {
        "!type": "fn(pattern: string, tidal_id?: number)",
        "!doc": "The tidal method enables you to easily sequence any method or property using the TidalCycles mini-notation. "
      },
      "tidals": {
        "!type": "[]",
        "!doc": "Stores all scheduler instances created by calling .tidal on this property/method."
      }

    },
    "number__sequencable": {
      "seq": {
        "!type": "fn(values: ?, timings?: ?, seq_id?: number)",
        "!doc": "The seq method enables you to easily sequence any method or property. You can pass a single value or an array of values for both the 'values' and 'timings' arguments. The timings argument will determine when the sequencer fires and the values argument will determine output."
      },
      "sequencers": {
        "!type": "[]",
        "!doc": "Stores all scheduler instances created by calling .seq on this property/method."
      },
      "start": {
        "!type": "fn()",
        "!doc": "Starts all seq and tidal schedulers controlling this property/method."
      },
      "stop": {
        "!type": "fn(pattern: string)",
        "!doc": "Stops all seq and tidal schedulers controlling this property/method."
      },
      "tidal": {
        "!type": "fn(pattern: string, tidal_id?: number)",
        "!doc": "The tidal method enables you to easily sequence any method or property using the TidalCycles mini-notation. "
      },
      "tidals": {
        "!type": "[]",
        "!doc": "Stores all scheduler instances created by calling .tidal on this property/method."
      }

    },

    "ugen": {
      "connect": {
        "!type": "fn(target?: ugen)",
        "!doc": "The connect function connects synthesis object to another synthesis object. If no object is passed as an argument, connect will connect to Gibber's Master bus."
      },
      "disconnect": "fn(target?: ugen)"
    },

    "instrument": {
      "!proto": "ugen",
      "note": {
        "!type": "fn(scaleIndex: number)",
        "!doc": "The note function triggers a new note using an argument scale index, which is converted into Hz and stored in the instrument's .frequency property.",
        "seq": {
          "!type": "fn(values: ?, timings?: ?, seq_id?: number)",
          "!doc": "The seq method enables you to easily sequence any method or property. You can pass a single value or an array of values for both the 'values' and 'timings' arguments. The timings argument will determine when the sequencer fires and the values argument will determine output."
        },
        "sequencers": {
          "!type": "[]",
          "!doc": "Stores all scheduler instances created by calling .seq on this property/method."
        },
        "start": {
          "!type": "fn()",
          "!doc": "Starts all seq and tidal schedulers controlling this property/method."
        },
        "stop": {
          "!type": "fn(pattern: string)",
          "!doc": "Stops all seq and tidal schedulers controlling this property/method."
        },
        "tidal": {
          "!type": "fn(pattern: string, tidal_id?: number)",
          "!doc": "The tidal method enables you to easily sequence any method or property using the TidalCycles mini-notation. "
        },
        "tidals": {
          "!type": "[]",
          "!doc": "Stores all scheduler instances created by calling .tidal on this property/method."
        }

      },
      "trigger": {
        "!type": "fn(loudness: number)",
        "!doc": "The trigger function triggers a new note using the argument loudness and, if appropriate, the current value of the instrument's .frequency property.",
        "seq": {
          "!type": "fn(values: ?, timings?: ?, seq_id?: number)",
          "!doc": "The seq method enables you to easily sequence any method or property. You can pass a single value or an array of values for both the 'values' and 'timings' arguments. The timings argument will determine when the sequencer fires and the values argument will determine output."
        },
        "sequencers": {
          "!type": "[]",
          "!doc": "Stores all scheduler instances created by calling .seq on this property/method."
        },
        "start": {
          "!type": "fn()",
          "!doc": "Starts all seq and tidal schedulers controlling this property/method."
        },
        "stop": {
          "!type": "fn(pattern: string)",
          "!doc": "Stops all seq and tidal schedulers controlling this property/method."
        },
        "tidal": {
          "!type": "fn(pattern: string, tidal_id?: number)",
          "!doc": "The tidal method enables you to easily sequence any method or property using the TidalCycles mini-notation. "
        },
        "tidals": {
          "!type": "[]",
          "!doc": "Stores all scheduler instances created by calling .tidal on this property/method."
        }

      }
    },
    "polyinstrument": {
      "!proto": "ugen",
      "note": {
        "!type": "fn(scaleIndex: number)",
        "!doc": "The note function triggers a new note using an argument scale index, which is converted into Hz and stored in the instrument's .frequency property.",
        "seq": {
          "!type": "fn(values: ?, timings?: ?, seq_id?: number)",
          "!doc": "The seq method enables you to easily sequence any method or property. You can pass a single value or an array of values for both the 'values' and 'timings' arguments. The timings argument will determine when the sequencer fires and the values argument will determine output."
        },
        "sequencers": {
          "!type": "[]",
          "!doc": "Stores all scheduler instances created by calling .seq on this property/method."
        },
        "start": {
          "!type": "fn()",
          "!doc": "Starts all seq and tidal schedulers controlling this property/method."
        },
        "stop": {
          "!type": "fn(pattern: string)",
          "!doc": "Stops all seq and tidal schedulers controlling this property/method."
        },
        "tidal": {
          "!type": "fn(pattern: string, tidal_id?: number)",
          "!doc": "The tidal method enables you to easily sequence any method or property using the TidalCycles mini-notation. "
        },
        "tidals": {
          "!type": "[]",
          "!doc": "Stores all scheduler instances created by calling .tidal on this property/method."
        }

      },
      "trigger": {
        "!type": "fn(loudness: number)",
        "!doc": "The trigger function triggers a new note using the argument loudness and, if appropriate, the current value of the instrument's .frequency property.",
        "seq": {
          "!type": "fn(values: ?, timings?: ?, seq_id?: number)",
          "!doc": "The seq method enables you to easily sequence any method or property. You can pass a single value or an array of values for both the 'values' and 'timings' arguments. The timings argument will determine when the sequencer fires and the values argument will determine output."
        },
        "sequencers": {
          "!type": "[]",
          "!doc": "Stores all scheduler instances created by calling .seq on this property/method."
        },
        "start": {
          "!type": "fn()",
          "!doc": "Starts all seq and tidal schedulers controlling this property/method."
        },
        "stop": {
          "!type": "fn(pattern: string)",
          "!doc": "Stops all seq and tidal schedulers controlling this property/method."
        },
        "tidal": {
          "!type": "fn(pattern: string, tidal_id?: number)",
          "!doc": "The tidal method enables you to easily sequence any method or property using the TidalCycles mini-notation. "
        },
        "tidals": {
          "!type": "[]",
          "!doc": "Stores all scheduler instances created by calling .tidal on this property/method."
        }

      }
    },

    "effect": {
      "!proto": "ugen",
      "input": {
        "!type": "ugen",
        "!doc": "default: 0 (silence). The input property provides the signal to be processed. This is automatically set when adding the effect to an effect chain on an instrument, or when calling instrument.connect( effect )."
      }
    },

    "freeverb": {
      "!proto": "effect",
      "!doc": "This is a reverberation model that uses four allpass filters in series and then eight comb filters in parallel. It is the same as the generic Reverb effect in Gibber.",
      "roomSize": {
        "!type": "number__sequencable",
        "!doc": "default: .925, range:0-.999. This controls the amount of feedback in the comb filters, which has the effect of shortening or lengthening thhe reverb tail."
      },
      "damping": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range:0–1. This controls the high frequency content in the reverberated signal."
      },
      "dry": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range:0–1. The amount of dry signal in the output. Set to 0 if you're using this on a bus, or to higher values if it is in an effecets chain."
      },
      "wet1": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range:0–1. Using different values for this and .wet2 will affect the stereo output by sending some of the left output to the right channel and vice versa. With a value of 1 for this property and 0 for .wet2 each output will only go to one channel."
      },
      "wet2": {
        "!type": "number__sequencable",
        "!doc": "default: .0, range:0–1. Using different values for this and .wet1 will affect the stereo output by sending some of the left output to the right channel and vice versa. With a value of 0 for this property and 1 for .wet1 each output will only go to one channel."
      }
    },
    "bitcrusher": {
      "!proto": "effect",
      "!doc": "A sample-rate / bit-rate reduction effect.",
      "bitDepth": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range:.01-1. This controls the number of bits in each processed sample. A value of 1 corresponds to 16-bits."
      },
      "sampleRate": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range:0–1. This controls the sampling rate of the input signal. A value of 1 equals whatever the sampling rate of the current session is."
      }
    },
    "delay": {
      "!proto": "effect",
      "!doc": "A feedback delay (echo) effect.",
      "time": {
        "!type": "duration",
        "!doc": "default: 1/8, range:1/512–1. This controls the amount of time betweeen echoes, or, if no feedback is applied, the amount of time between the original signal and the delayed signal."
      },
      "feedback": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range:0–1. This controls the amount of feedback, which determines how long the echoes carry on for. Note that values over 1 can produce an interesting effect, but will eventually blow up your speakers and potentially your ears... be careful!"
      }
    },
    "wavefolder": {
      "!proto": "effect",
      "!doc": "A wavefolding effect, where a signal is 'folded' repeatedly when it exceeds a certain threshold, adding spectral complexity and creating distortion.",
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: 2, range:0-???. This the boost that is applied to the input signal; applying more of a boost will create more distortion."
      },
      "postgain": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range:0–1. This property can be used to decrease the volume of the signal after it has gone through the wavefolder."
      }
    },
    "distortion": {
      "!proto": "effect",
      "!doc": "A waveshaping distortion taken from Csound, which calls it a 'modified hyperbolic tangent distortion'.",
      "pregain": {
        "!type": "number__sequencable",
        "!doc": "default: 5, range:0-???. This the boost that is applied to the input signal; applying more of a boost will create more distortion."
      },
      "postgain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range:0–1. This property can be used to decrease the volume of the signal after it has gone through the waveshaper."
      },
      "shape1": {
        "!type": "number__sequencable",
        "!doc": "default: .1, range:-5–5. This property controls the waveshaping of the positive part of the signal. A value of 0 gives a flat clip."
      },
      "shape2": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range:0–1. This property controls the waveshaping of the negative part of the signal. A value of 0 gives a flat clip."
      }
    },
    "flanger": {
      "!proto": "effect",
      "!doc": "The classic flanging effect featuring a modulated delay line with feedback.",
      "frequency": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range:.0001-???. This controls the frequnecy of the sine oscillator that is modulating the lookup in the delay line."
      },
      "feedback": {
        "!type": "number__sequencable",
        "!doc": "default: .84, range:0–1. This controls the amount of feedback in the delay line."
      },
      "offset": {
        "!type": "number__sequencable",
        "!doc": "default: .125, range:.01–1. This controls how far back the delay line is reading from. Larger values yield more dramatic results. A value of 1 === 500 samples in the past."
      }
    },
    "vibrato": {
      "!proto": "effect",
      "!doc": "An effect that modulates the pitch of an incoming signal over time.",
      "frequency": {
        "!type": "number__sequencable",
        "!doc": "default: 4, range:.0001-???. This controls the frequnecy of the modulating oscillator."
      },
      "feedback": {
        "!type": "number__sequencable",
        "!doc": "default: .01, range:0–1. Although not used for traditional vibrato, increasing the feedback amount can introduce interesting distortions."
      },
      "amount": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range:.01–1. Controls the width of the vibrato, or how much the pitch fluctuates."
      }
    },
    "tremolo": {
      "!proto": "effect",
      "!doc": "An effect that modulates the volume of an input sigal over time.",
      "frequency": {
        "!type": "number__sequencable",
        "!doc": "default: 2, range:.0001-???. This controls the frequency of the moduluating oscillator."
      },
      "amount": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range:.01–1. Controls the width of the tremolo, or how much the amplitude fluctuates."
      },
      "shape": {
        "!type": "string",
        "!doc": "default: 'sine'. Controls the type of oscillation; options are 'sine', 'square', and 'saw'."
      }
    },


    "sampler": {
      "!proto": "instrument",
      "rate": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range -100–100. This controls the rate of sample playback. Higher speeds will result in higher pitches; negative numbers will play samples backwards."
      },
      "start": {
        "!type": "number__sequencable",
        "!doc": "default: 0, range 0–1. This determines where sample playback begins, for example, a value of .5 would start the sample in the middle when triggered."
      },
      "end": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–1. This determines where sample playback ends. A value of 1 means that the sample will play to its end."
      },
      "loops": {
        "!type": "number__sequencable",
        "!doc": "default: 0. 0 or 1. When set to a value of 1 sample playback will loop according to the sampler's .start and .end properties."
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–1. Loudness linearly controls the signal pre-filter."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. This linearly controls the overall output (sometimes known as volume) of the synth."
      },
      "panVoices": {
        "!type": "bool",
        "!doc": "default true. When set to true the instrument can be panned through the stereo sound image, adding a slight amount of computational expense."
      },
      "pan": {
        "!type": "number__sequencable",
        "!doc": "default .5, range 0–1. Controls the position of the sound between the left / right speakers or headphones. A value of 0 means the sound is panned to the left, a value of 1 meanns the sound is panned to the right, while .5 is centered."
      }

    },

    "kick": {
      "!proto": "instrument",
      "!doc": "The Kick unit generator emulates the kick sound found on the Roland TR-808 drum machine, a classic in hip-hop. It consists of an impulse feeding resonant bandpass and hipass filters scaled by an exponential decay.",
      "frequency": {
        "!type": "number__sequencable",
        "!doc": "default: 85, range 40–8000. The pitch of the kick drum."
      },
      "decay": {
        "!type": "number__sequencable",
        "!doc": "default: .9, range 0–1. Controls the length of each kick drum. Very high values (~.975 and above) result in long, booming sub-bass sounds."
      },
      "tone": {
        "!type": "number__sequencable",
        "!doc": "default: .25, range 0–1. Controls the amount of a high-frequency click at the start of each hit"
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–1. Loudness linearly controls the signal pre-filter."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. This linearly controls the overall output (sometimes known as volume) of the synth."
      }
    },

    "snare": {
      "!proto": "instrument",
      "!doc": "The Snare instrument emulates the snare found on the Roland TR-808 drum machine. It consists of an two resonant bandpass filters mixed with high-passed noise, all scaled by an exponential decay.",
      "tune": {
        "!type": "number__sequencable",
        "!doc": "default: 0, range -4–4. The pitch of the snare drum."
      },
      "decay": {
        "!type": "number__sequencable",
        "!doc": "default: .1, range 0–1. Controls the length of each snare drum hit."
      },
      "snappy": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–1. Controls the amount of a high-frequency click at the start of each hit"
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–5. Loudness linearly controls the signal pre-filter."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. This linearly controls the overall output (sometimes known as volume) of the synth."
      }
    },

    "hat": {
      "!proto": "instrument",
      "!doc": "The Hat instrument emulates the hihat found on the Roland TR-808 drum machine. It consists of six tuned square waves feeding bandpass and highpass filters scaled by an exponential decay.",
      "tune": {
        "!type": "number__sequencable",
        "!doc": "default: .6, range 0–.8. The tuning of the hihat cymbals."
      },
      "decay": {
        "!type": "number__sequencable",
        "!doc": "default: .1, range 0–1. Controls the length of each hihat hit."
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–5. Loudness linearly controls the signal pre-filter."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. This linearly controls the overall output (sometimes known as volume) of the synth."
      }
    },
    "clap": {
      "!proto": "instrument",
      "!doc": "The Clap instrument poorly emulates the clap found on the Roland TR-808 drum machine, with three enveloped and filtered noise bursts slightly offset from each other in time.",
      "spacing": {
        "!type": "number__sequencable",
        "!doc": "default: 100, range 1-1000. The spacing, in Hz, between each noise envelope."
      },
      "decay": {
        "!type": "number__sequencable",
        "!doc": "default: .2, range 0–1. Controls the length of each clap."
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–5. Loudness linearly controls the signal pre-filter."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. This linearly controls the overall output (sometimes known as volume) of the synth."
      }
    },
    "cowbell": {
      "!proto": "instrument",
      "!doc": "The Cowbell instrument emulates the iconic cowbell found on the Roland TR-808 drum machine, with two enveloped and filtered square waves.",
      "decay": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. Controls the length of each cowbell strike."
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–5. Loudness linearly controls the signal pre-filter."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. This linearly controls the overall output (sometimes known as volume) of the synth."
      }
    },
    "edrums": {
      "!proto": "ugen",
      "!doc": "The EDrums object is many of the synthetic drums sounds inspired by the 808 grouped together into a single output. You can sequence the different instruments by referring to them with the kd (kick drum), sd (snare drum), ch (closed hat), cp (clap), cb (cowbell), and oh (open hat) shorthands. You can also access each instrument individually to change gain, panning, and other properties.",
      "seq": {
        "!type": "fn(values: ?, timings?: ?, seq_id?: number)",
        "!doc": "The seq method enables you to easily sequence any method or property. You can pass a single value or an array of values for both the 'values' and 'timings' arguments. The timings argument will determine when the sequencer fires and the values argument will determine output."
      },
      "sequencers": {
        "!type": "[]",
        "!doc": "Stores all scheduler instances created by calling .seq on this property/method."
      },
      "stop": {
        "!type": "fn(pattern: string)",
        "!doc": "Stops all seq and tidal schedulers controlling this property/method."
      },
      "tidal": {
        "!type": "fn(pattern: string, tidal_id?: number)",
        "!doc": "The tidal method enables you to easily sequence any method or property using the TidalCycles mini-notation. For the Drums object, you can sequence the different samplers by referring to them with the kd (kick drum), sd (snare drum), ch (closed hat), and oh (open hat) shorthands."
      },
      "tidals": {
        "!type": "[]",
        "!doc": "Stores all scheduler instances created by calling .tidal on this property/method."
      },
      "kick": {
        "!type": "kick",
        "!doc": "Kick instrument"
      },
      "snare": {
        "!type": "snare",
        "!doc": "Snare instrument."
      },
      "closedHat": {
        "!type": "hat",
        "!doc": "Hat instrument with short decay time."
      },
      "openHat": {
        "!type": "hat",
        "!doc": "Hat instrument with longer decay time."
      },
      "clap": {
        "!type": "clap",
        "!doc": "Clap instrument."
      },
      "cowbell": {
        "!type": "cowbell",
        "!doc": "Cowbell instrument."
      },
      "panVoices": {
        "!type": "bool",
        "!doc": "default true. When set to true the instrument can be panned through the stereo sound image, adding a slight amount of computational expense."
      },
      "pan": {
        "!type": "number__sequencable",
        "!doc": "default .5, range 0–1. Controls the position of the sound between the left / right speakers or headphones. A value of 0 means the sound is panned to the left, a value of 1 meanns the sound is panned to the right, while .5 is centered."
      }

    },
    "drums": {
      "!proto": "ugen",
      "!doc": "The Drums object is four samplers grouped together into a single output. You can sequence the different samplers by referring to them with the kd (kick drum), sd (snare drum), ch (closed hat), and oh (open hat) shorthands. You can also access each sampler individually to change gain, panning, and other properties.",
      "rate": {
        "!doc": "default: 1, range -100 100. Global control of the each sampler's playback rate.",
        "!type": "number__sequencable"
      },
      "start": {
        "!doc": "default: 0, range 0–1. Global control of the each sampler's starting position.",
        "!type": "number__sequencable"
      },
      "end": {
        "!doc": "default: 1, range 0–1. Global control of the each sampler's ending position.",
        "!type": "number__sequencable"
      },
      "seq": {
        "!type": "fn(values: ?, timings?: ?, seq_id?: number)",
        "!doc": "The seq method enables you to easily sequence any method or property. You can pass a single value or an array of values for both the 'values' and 'timings' arguments. The timings argument will determine when the sequencer fires and the values argument will determine output."
      },
      "sequencers": {
        "!type": "[]",
        "!doc": "Stores all scheduler instances created by calling .seq on this property/method."
      },
      "stop": {
        "!type": "fn(pattern: string)",
        "!doc": "Stops all seq and tidal schedulers controlling this property/method."
      },
      "tidal": {
        "!type": "fn(pattern: string, tidal_id?: number)",
        "!doc": "The tidal method enables you to easily sequence any method or property using the TidalCycles mini-notation. For the Drums object, you can sequence the different samplers by referring to them with the kd (kick drum), sd (snare drum), ch (closed hat), and oh (open hat) shorthands."
      },
      "tidals": {
        "!type": "[]",
        "!doc": "Stores all scheduler instances created by calling .tidal on this property/method."
      },
      "kick": {
        "!type": "sampler",
        "!doc": "Sampler that is loaded with a kick drum sample."
      },
      "snare": {
        "!type": "sampler",
        "!doc": "Sampler that is loaded with a snare drum sample."
      },
      "closedHat": {
        "!type": "sampler",
        "!doc": "Sampler that is loaded with a closed hihat sample."
      },
      "openHat": {
        "!type": "sampler",
        "!doc": "Sampler that is loaded with a open hihat sample."
      },
      "panVoices": {
        "!type": "bool",
        "!doc": "default true. When set to true the instrument can be panned through the stereo sound image, adding a slight amount of computational expense."
      },
      "pan": {
        "!type": "number__sequencable",
        "!doc": "default .5, range 0–1. Controls the position of the sound between the left / right speakers or headphones. A value of 0 means the sound is panned to the left, a value of 1 meanns the sound is panned to the right, while .5 is centered."
      }

    },

    "pluck": {
      "!proto": "instrument",
      "!doc": "A physically modeled string instrument, using the Karplus-Strong model.",
      "blend": {
        "!doc": "default: 1, range 0–1. A feature of the model used for this instrument is that it is easy to randomly add noise to the signal. Values slightly less than 1 will produce notes that sound almost errant, while values closer to .5 will produce bursts of noise and can be a useful percussive texture.",
        "!type": "number__sequencable"
      },
      "decay": {
        "!doc": "default: .97, range 0–1. Controls the time it takes for each note to fade to silence.",
        "!type": "number__sequencable"
      },
      "damping": {
        "!doc": "default: .2, range 0–1. Controls the amount of high frequency damping, or brightness, of the sound.",
        "!type": "number__sequencable"
      },
      "frequency": {
        "!type": "number__sequencable",
        "!doc": "default: 220, range 40–8000. This is the frequency that will be used when the .trigger() method is called, or if you call .note() and pass no argument. Calls to .note() (assuming you pass an argument) will set the value of this property."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. This linearly controls the overall output (sometimes known as volume) of the synth."
      },
      "glide": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 1–4000. The glide property controls a single-pole lowpass filter on the frequency, causing notes to slide from one to the next (portamento). The filter equation is: y (n) = y (n-1) + ((x (n) - y (n-1))/glide). A value of 1 generates no glide, a value of 1500 generates a substantial glide."
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–1. Loudness linearly controls the signal pre-filter. Additionally, when the synth's filter is enabled loudness will modulate the cutoff frequency of the filter... 'louder' sounds will be perceptually brighter as well."
      },
      "panVoices": {
        "!type": "bool",
        "!doc": "default true. When set to true the instrument can be panned through the stereo sound image, adding a slight amount of computational expense."
      },
      "pan": {
        "!type": "number__sequencable",
        "!doc": "default .5, range 0–1. Controls the position of the sound between the left / right speakers or headphones. A value of 0 means the sound is panned to the left, a value of 1 meanns the sound is panned to the right, while .5 is centered."
      }

    },

    "synth": {
      "!proto": "instrument",
      "!doc": "The Synth object pairs a single oscillator, an envelope, and a filter. The envelope controls both the gain of the synth (volume) and the cutoff frequency of the filter, make its sound brighter when the envelope is fully open.",
      "waveform": {
        "!type": "string",
        "!doc": "default: 'sine'. Controls the waveform of the synth's oscillator. Options include 'saw', 'triangle', 'pwm', 'sine', 'square', and 'noise'."
      },
      "frequency": {
        "!type": "number__sequencable",
        "!doc": "default: 220, range 40–8000. This is the frequency that will be used when the .trigger() method is called, or if you call .note() and pass no argument. Calls to .note() (assuming you pass an argument) will set the value of this property."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5, range 0–1. This linearly controls the overall output (sometimes known as volume) of the synth."
      },
      "glide": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 1–4000. The glide property controls a single-pole lowpass filter on the frequency, causing notes to slide from one to the next (portamento). The filter equation is: y (n) = y (n-1) + ((x (n) - y (n-1))/glide). A value of 1 generates no glide, a value of 1500 generates a substantial glide."
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1, range 0–1. Loudness linearly controls the signal pre-filter. Additionally, when the synth's filter is enabled loudness will modulate the cutoff frequency of the filter... 'louder' sounds will be perceptually brighter as well."
      },
      "antialias": {
        "!type": "bool",
        "!doc": "default: false. When set to true, the synth's oscillators will use higher-quality (but more CPU expensive) anti-aliasing oscillators."
      },
      "attack": {
        "!type": "duration",
        "!doc": "The attack property controls the duration it takes for the synth to reach full volume after triggering. The duration is written in measures. A value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "decay": {
        "!type": "duration",
        "!doc": "The decay property controls the length of time it takes for the synth to decay to silence after reaching full volume during its attack phase. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "sustain": {
        "!type": "duration",
        "!doc": "The sustain property controls the length of time the synths envelope stays at steady state after the attack and decay of the envelope have completed. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "release": {
        "!type": "duration",
        "!doc": "The release determines the amount of time the envelope takes to fade to zero after the sustain portion is complete. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measurei."
      },
      "shape": {
        "!type": "string",
        "!doc": "default: 'linear'. Controls the shape of the synth's envelope stages. Choosee between 'linear' and 'exponential'."
      },
      "useADSR": {
        "!type": "bool",
        "!doc": "default: false. When false, the synth uses a two-stage envelope where durations are determined by the attack and decay properties. When true, the synth uses a four-stage envelope."
      },
      "cutoff": {
        "!type": "number__sequencable",
        "!doc": "default: .5. The cutoff property provides a base for determining the cutoff frequency of the filter. The frequency is additionally affected by the envelope of the synth, multiplied by the filterMult property."
      },
      "Q": {
        "!type": "number__sequencable",
        "!doc": "default: .25 The Q property (also commonly known as resonance) determines the sharpness of the filter. This is canonically accompanied by a boost around the cutoff frequency; if the Q property is high enough this boost can turn into self-oscillation."
      },
      "filterMult": {
        "!type": "number__sequencable",
        "!doc": "default: 2. The filterMult property determines how much the cutoff frequency is affected by each synth's envelope. The default value of 2 means that a cutoff frequency would move between .25 and .5 over the course of the envelope."
      },
      "filterType": {
        "!type": "number",
        "!doc": "default: 1. The filterType property determines what filter modeling algorithm is used. 0 means no filter is applied to the synth, 1 uses a Moog Ladder Filter, 2 uses  a TB303-style diode filter, 3 uses a state variable filter, and 4 uses a biquad filter design."
      },
      "filterMode": {
        "!type": "number",
        "!doc": "default: 0. The filterMode property determines the type of filtering employed, however, some filter types do not support highpass or bandpass filtering. 0 = lowpass, 1 = highpass, 2 = bandpass."
      },
      "saturation": {
        "!type": "number__sequencable",
        "!doc": "default: .5. Saturation is a waveshaping distortion that is part of the TB303 diode filter model (filterType 2). This property will have no effect for any other value of filterType."
      },
      "panVoices": {
        "!type": "bool",
        "!doc": "default true. When set to true the instrument can be panned through the stereo sound image, adding a slight amount of computational expense."
      },
      "pan": {
        "!type": "number__sequencable",
        "!doc": "default .5, range 0–1. Controls the position of the sound between the left / right speakers or headphones. A value of 0 means the sound is panned to the left, a value of 1 meanns the sound is panned to the right, while .5 is centered."
      }

    },
    "monosynth": {
      "!proto": "instrument",
      "!doc": "The Monosynth object pairs three oscillators, an envelope, and a filter. The envelope controls both the gain of the synth (volume) and the cutoff frequency of the filter, make it's sound brighter when the envelope is fully open. Oscillators can be detuned from each other creating a fuller sound than a single oscillator alone.",
      "detune2": {
        "!type": "number__sequencable",
        "!doc": "default: .005. The frequency for oscillator #2 will be determined by taking the value of the .frequency property (which controls the frequency of oscillator #1) and offsetting it by the the value of this property multiplied by the base frequency. So, if the base .frqeuency property was 1000 Hz, oscillator #2 would run at a frequency of 1005 Hz using the default value of .005"
      },
      "detune3": {
        "!type": "number__sequencable",
        "!doc": "default: -.005. The frequency for oscillator #3 will be determined by taking the value of the .frequency property (which controls the frequency of oscillator #1) and offsetting it by the the value of this property multiplied by the base frequency. So, if the base .frqeuency property was 1000 Hz, oscillator #3 would run at a frequency of 995 Hz using the default value of -.005"
      },
      "frequency": {
        "!type": "number__sequencable",
        "!doc": "default: 220. This is the frequency that will be used when the .trigger() method is called, or if you call .note() and pass no argument. Calls to .note() (assuming you pass an argument) will set the value of this property."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5. This linearly controls the overall output (sometimes known as volume) of the synth."
      },
      "glide": {
        "!type": "number__sequencable",
        "!doc": "default: 1. The glide property controls a single-pole lowpass filter on the frequency, causing notes to slide from one to the next (portamento). The filter equation is: y (n) = y (n-1) + ((x (n) - y (n-1))/glide). A value of 1 generates no glide, a value of 1500 generates a substantial glide."
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1. Loudness linearly controls the signal pre-filter. Additionally, when the synth's filter is enabled loudness will modulate the cutoff frequency of the filter... 'louder' sounds will be perceptually brighter as well."
      },
      "antialias": {
        "!type": "bool",
        "!doc": "default: false. When set to true, the synth's oscillators will use higher-quality (but more CPU expensive) anti-aliasing oscillators."
      },
      "attack": {
        "!type": "duration",
        "!doc": "The attack property controls the duration it takes for the synth to reach full volume after triggering. The duration is written in measures. A value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "decay": {
        "!type": "duration",
        "!doc": "The decay property controls the length of time it takes for the synth to decay to silence after reaching full volume during its attack phase. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "sustain": {
        "!type": "duration",
        "!doc": "The sustain property controls the length of time the synths envelope stays at steady state after the attack and decay of the envelope have completed. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "release": {
        "!type": "duration",
        "!doc": "The release determines the amount of time the envelope takes to fade to zero after the sustain portion is complete. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measurei."
      },
      "shape": {
        "!type": "string",
        "!doc": "default: 'linear'. Controls the shape of the synth's envelope stages. Choosee between 'linear' and 'exponential'."
      },
      "useADSR": {
        "!type": "bool",
        "!doc": "default: false. When false, the synth uses a two-stage envelope where durations are determined by the attack and decay properties. When true, the synth uses a four-stage envelope."
      },
      "cutoff": {
        "!type": "number__sequencable",
        "!doc": "default: .5. The cutoff property provides a base for determining the cutoff frequency of the filter. The frequency is additionally affected by the envelope of the synth, multiplied by the filterMult property."
      },
      "Q": {
        "!type": "number__sequencable",
        "!doc": "default: .25 The Q property (also commonly known as resonance) determines the sharpness of the filter. This is canonically accompanied by a boost around the cutoff frequency; if the Q property is high enough this boost can turn into self-oscillation."
      },
      "filterMult": {
        "!type": "number__sequencable",
        "!doc": "default: 2. The filterMult property determines how much the cutoff frequency is affected by each synth's envelope. The default value of 2 means that a cutoff frequency would move between .25 and .5 over the course of the envelope."
      },
      "filterType": {
        "!type": "number",
        "!doc": "default: 1. The filterType property determines what filter modeling algorithm is used. 0 means no filter is applied to the synth, 1 uses a Moog Ladder Filter, 2 uses  a TB303-style diode filter, 3 uses a state variable filter, and 4 uses a biquad filter design."
      },
      "filterMode": {
        "!type": "number",
        "!doc": "default: 0. The filterMode property determines the type of filtering employed, however, some filter types do not support highpass or bandpass filtering. 0 = lowpass, 1 = highpass, 2 = bandpass."
      },
      "saturation": {
        "!type": "number__sequencable",
        "!doc": "default: .5. Saturation is a waveshaping distortion that is part of the TB303 diode filter model (filterType 2). This property will have no effect for any other value of filterType."
      },
      "panVoices": {
        "!type": "bool",
        "!doc": "default true. When set to true the instrument can be panned through the stereo sound image, adding a slight amount of computational expense."
      },
      "pan": {
        "!type": "number__sequencable",
        "!doc": "default .5, range 0–1. Controls the position of the sound between the left / right speakers or headphones. A value of 0 means the sound is panned to the left, a value of 1 meanns the sound is panned to the right, while .5 is centered."
      }

    },
    "fm": {
      "!proto": "instrument",
      "!doc": "The FM object pairs two oscillators (with one modulating the frequency of the other), an envelope, and a filter. The envelope controls the amplitude of the modulator (also known as the modulation index) , the overall gain of the synth (volume), and the cutoff frequency of the filter, make its sound perceptually brighter when the envelope is fully open.",
      "cmRatio": {
        "!type": "number__sequencable",
        "!doc": "default: 2. This controls the ratio between the carrier and modulation frequencies. When a note is trigger on this synth the frequency is assigned to the carrier oscillator; the frequency is then multiplied by this property and assigned ot the modulator."
      },
      "index": {
        "!type": "number__sequencable",
        "!doc": "default: 2. This property value, multiplied by the frequency of the carrier oscillator, determines the amplitude of the modulating oscillator."
      },
      "feedback": {
        "!type": "number__sequencable",
        "!doc": "default: 0. The modulating oscillator can direct its output to modulate its own frequency, resulting in chaotic and noisy sounds."
      },
      "carrierWaveform": {
        "!type": "string",
        "!doc": "default: 'sine'. Controls the waveform of the carrier oscillator. Options include 'saw', 'triangle', 'pwm', 'sine', 'square', and 'noise'."
      },
      "modulatorWaveform": {
        "!type": "string",
        "!doc": "default: 'sine'. Controls the waveform of the modulating oscillator. Options include 'saw', 'triangle', 'pwm', 'sine', 'square', and 'noise'."
      },
      "frequency": {
        "!type": "number__sequencable",
        "!doc": "default: 220. This is the frequency that will be used when the .trigger() method is called, or if you call .note() and pass no argument. Calls to .note() (assuming you pass an argument) will set the value of this property."
      },
      "gain": {
        "!type": "number__sequencable",
        "!doc": "default: .5. This linearly controls the overall output (sometimes known as volume) of the synth."
      },
      "glide": {
        "!type": "number__sequencable",
        "!doc": "default: 1. The glide property controls a single-pole lowpass filter on the frequency, causing notes to slide from one to the next (portamento). The filter equation is: y (n) = y (n-1) + ((x (n) - y (n-1))/glide). A value of 1 generates no glide, a value of 1500 generates a substantial glide."
      },
      "loudness": {
        "!type": "number__sequencable",
        "!doc": "default: 1. Loudness linearly controls the signal pre-filter. Additionally, when the synth's filter is enabled loudness will modulate the cutoff frequency of the filter... 'louder' sounds will be perceptually brighter as well."
      },
      "antialias": {
        "!type": "bool",
        "!doc": "default: false. When set to true, the synth's oscillators will use higher-quality (but more CPU expensive) anti-aliasing oscillators."
      },
      "attack": {
        "!type": "duration",
        "!doc": "The attack property controls the duration it takes for the synth to reach full volume after triggering. The duration is written in measures. A value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "decay": {
        "!type": "duration",
        "!doc": "The decay property controls the length of time it takes for the synth to decay to silence after reaching full volume during its attack phase. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "sustain": {
        "!type": "duration",
        "!doc": "The sustain property controls the length of time the synths envelope stays at steady state after the attack and decay of the envelope have completed. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measure."
      },
      "release": {
        "!type": "duration",
        "!doc": "The release determines the amount of time the envelope takes to fade to zero after the sustain portion is complete. The duration is written in measures e.g. a value of 1/4 means one quarter of a measure, a value of 1 means 1 measurei."
      },
      "shape": {
        "!type": "string",
        "!doc": "default: 'linear'. Controls the shape of the synth's envelope stages. Choosee between 'linear' and 'exponential'."
      },
      "useADSR": {
        "!type": "bool",
        "!doc": "default: false. When false, the synth uses a two-stage envelope where durations are determined by the attack and decay properties. When true, the synth uses a four-stage envelope."
      },
      "cutoff": {
        "!type": "number__sequencable",
        "!doc": "default: .5. The cutoff property provides a base for determining the cutoff frequency of the filter. The frequency is additionally affected by the envelope of the synth, multiplied by the filterMult property."
      },
      "Q": {
        "!type": "number__sequencable",
        "!doc": "default: .25 The Q property (also commonly known as resonance) determines the sharpness of the filter. This is canonically accompanied by a boost around the cutoff frequency; if the Q property is high enough this boost can turn into self-oscillation."
      },
      "filterMult": {
        "!type": "number__sequencable",
        "!doc": "default: 2. The filterMult property determines how much the cutoff frequency is affected by each synth's envelope. The default value of 2 means that a cutoff frequency would move between .25 and .5 over the course of the envelope."
      },
      "filterType": {
        "!type": "number",
        "!doc": "default: 1. The filterType property determines what filter modeling algorithm is used. 0 means no filter is applied to the synth, 1 uses a Moog Ladder Filter, 2 uses  a TB303-style diode filter, 3 uses a state variable filter, and 4 uses a biquad filter design."
      },
      "filterMode": {
        "!type": "number",
        "!doc": "default: 0. The filterMode property determines the type of filtering employed, however, some filter types do not support highpass or bandpass filtering. 0 = lowpass, 1 = highpass, 2 = bandpass."
      },
      "saturation": {
        "!type": "number__sequencable",
        "!doc": "default: .5. Saturation is a waveshaping distortion that is part of the TB303 diode filter model (filterType 2). This property will have no effect for any other value of filterType."
      },
      "panVoices": {
        "!type": "bool",
        "!doc": "default true. When set to true the instrument can be panned through the stereo sound image, adding a slight amount of computational expense."
      },
      "pan": {
        "!type": "number__sequencable",
        "!doc": "default .5, range 0–1. Controls the position of the sound between the left / right speakers or headphones. A value of 0 means the sound is panned to the left, a value of 1 meanns the sound is panned to the right, while .5 is centered."
      }

    }
  },


  "Monosynth": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> monosynth",
    "!doc": "Constructor for a three-oscillator synth with a filter and envelope. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset"
  },
  "Synth": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> synth",
    "!doc": "Constructor for a single oscillator synth with a filter and envelope. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset"
  },
  "FM": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> fm",
    "!doc": "Constructor for a two-operator FM synthesizer. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset"
  },
  "Pluck": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> pluck",
    "!doc": "Constructor for physically-modeled string instrument (Karplus-Strong). The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Drums": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> drums",
    "!doc": "Constructor for sample-based drum instrument, featuring samples for kick, snare, closed hihat, and open hihat sounds. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "EDrums": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> edrums",
    "!doc": "Constructor for synthetic drum instrument, featuring synthesizers for kick, snare, closed hihat, open hihat, clap, and cowbell sounds. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Kick": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> kick",
    "!doc": "Constructor for synthetic kick drum in the style of the Roland TR-808. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Snare": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> snare",
    "!doc": "Constructor for a synthetic snare drum in the style of the TR-808. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Hat": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> hat",
    "!doc": "Constructor for a synthetic hihat in the style of the TR-808. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Clap": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> clap",
    "!doc": "Constructor for a synthetic clap in the style of the TR-808. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Cowbell": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> cowbell",
    "!doc": "Constructor for a synthetic cowbell in the style of the TR-808. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Freeverb": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> freeverb",
    "!doc": "Constructor for a reverb. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Bitcrusher": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> bitcrusher",
    "!doc": "Constructor for a bitcrusher effect. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Delay": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> delay",
    "!doc": "Constructor for a delay effect. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Wavefolder": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> wavefolder",
    "!doc": "Constructor for a wavefolder distortion effect. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Distortion": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> distortion",
    "!doc": "Constructor for a waveshaper distortion effect. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Flanger": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> flanger",
    "!doc": "Constructor for a flanger effect. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Vibrato": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> vibrato",
    "!doc": "Constructor for a vibrato effect. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  },
  "Tremolo": {
    "!type": "fn(initializer?: properties|string, presetMods?: properties) -> tremolo",
    "!doc": "Constructor for a tremolo effect. The constructor can accept two types of arguments: pass an object specifying property values for the new object, or, pass a preset name and an optional object containing modifications to the preset."
  }
}